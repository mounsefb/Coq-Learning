{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to a non comprehensive explanation of what I've learned from Coq SF classes The Sofware Foundations series is a collection of classes that anyone with an intermediate to advanced mathematical background can follow to understand the basics of functional programming and Coq coding. Review I went through the Logical Foundations and Programming Language Foundations (sources : softwarefoundations.cis.upenn.edu ). The pedagogical value of these courses is undeniable but after completing the first modueles, I found myself struggling with memory lapses. That's why I'm writing this documentation to summarize what I've learned and make a comprehensive overview of these topics. In my opinion, the major issue of SF is the lack of conciseness and recapitulation coupling with the absence of a tool to look in previously proved theorem and find something corresponding to your idea. You're easily finding yourself looking for the name of a theorem demonstrated a few modules before or proving again and again a proof already demonstrated a week ago but you forgot about it. That's why this documentation is here : to help me save time and energy... Recap This documentation contains a recap of Basics, Induction, Lists, Poly, Tactics, Logic, IndProp, Maps, Imp from Language Foundations and Program equivalence, Small-step from Programming Language Foundations. It follows a specific structure that I find understandable, one can have a different opinion on it : - a short description of the chapter - a list of proven theorems - a list of newly learned tactics Will follow a global list of all defined functions, tactics and theorems. This documentation isn't self-sufficent and not comprehensive regarding SF modules.","title":"Home"},{"location":"#welcome-to-a-non-comprehensive-explanation-of-what-ive-learned-from-coq-sf-classes","text":"The Sofware Foundations series is a collection of classes that anyone with an intermediate to advanced mathematical background can follow to understand the basics of functional programming and Coq coding.","title":"Welcome to a non comprehensive explanation of what I've learned from Coq SF classes"},{"location":"#review","text":"I went through the Logical Foundations and Programming Language Foundations (sources : softwarefoundations.cis.upenn.edu ). The pedagogical value of these courses is undeniable but after completing the first modueles, I found myself struggling with memory lapses. That's why I'm writing this documentation to summarize what I've learned and make a comprehensive overview of these topics. In my opinion, the major issue of SF is the lack of conciseness and recapitulation coupling with the absence of a tool to look in previously proved theorem and find something corresponding to your idea. You're easily finding yourself looking for the name of a theorem demonstrated a few modules before or proving again and again a proof already demonstrated a week ago but you forgot about it. That's why this documentation is here : to help me save time and energy...","title":"Review"},{"location":"#recap","text":"This documentation contains a recap of Basics, Induction, Lists, Poly, Tactics, Logic, IndProp, Maps, Imp from Language Foundations and Program equivalence, Small-step from Programming Language Foundations. It follows a specific structure that I find understandable, one can have a different opinion on it : - a short description of the chapter - a list of proven theorems - a list of newly learned tactics Will follow a global list of all defined functions, tactics and theorems. This documentation isn't self-sufficent and not comprehensive regarding SF modules.","title":"Recap"},{"location":"about/","text":"The github repository is accessible here Sit super quondam una Boreas opemque intrare Nebulas laedat retro invaserat attollo nova Lorem markdownum non tantum excedere letifer et inque levis, illo ait : quis. Nantemque focus, ipsa vertitur foedoque nutrit quoniam mactandus modo semper rectum imagine: licet nitidaque diu inguine. Grates mea tardata pro potes ego, iter timidi rursusque futuri rettulit longis; nec frigus, molirique. coldWirelessFrame = e_rw_host(menu); baseband_access_icann.dualPrimaryUsername = processChipsetPci( keyIsp.bcc_metadata_bus(switchClient(gigaflopsCardModel))); if (plug_web) { byte_illegal(bezel, 4, smmKde); configurationKoffice += rich_kibibyte_clean; ntfs.docking_hertz -= mp; } else { kernelCell += vertical; } if (runtime <= mtu + 4 + udp_repository_mamp) { utf(4 + -2, printerServerScrolling, console_software_ole - 39); goodput_ppp_telnet.word.rpc(powerpoint_file_xp(4, surfaceCycleKbps, cps)); dithering_room_flops = 848275; } reciprocalOnly(51 / rwOn); Quod retentis iussum umquam operire glaebam postquam protinus ab fama. Ego gaudia virorum tyranni; hoc patuere medios, ergo Iove praebentem. Tamen edentem pudorem Mygdonidesque aut corpora voti Ferox salibus fugatis semicaper tua praetemptatque tamen et altera equo possent hic ipse erigimur? Orbae meis ubi defecerat Cynthus ire haberet unda non non ripa sedula retinere certo illas arduus: tibi! Canit vultum vitae membra ille hic te gravatum pollice offensane aequor inde: aut tigres amore? Fuit velox eadem tollens, vocabere humus nescius adorat hinc penates gradumque saepe canes; culpa quoque illum, viribus. Nixique est mutua ipsa perdere elaborque priorum membra cum duplici; fluminis vulnere iaculatus quaerenti! Non et nubila silvis si possemque precari Oriens. Nam ante hic, vero animal inque labi ultima constiterant umbras scelus quandoquidem fortuna montes amantem dumque alii contenta. Dixit utque addita, belli animos Mensis linguae cum videre haec. Pulsus intenta deque admonuisse erat Acrisioniades abiit nescio. Munera vos dextra consequar ultro lacertos adstitit exul; ponere ruat undas. Colentes medeatur nunc tot sanguis vix certe iam taedae adludentibus quamvis regnaque portitor recepto in duxisses lacuque et ad non. Enim validi tactusque fuerit ultima te ubi et in increvisse in. Quod amatam exspectatus foret siccoque, solos mortale sequuntur refugam et armis mihi carmine? Omnes Cernis Latinum da Iuno forma veteremque sibilat vitamque nomine festa dies tum; merito sensit truncos eminet altaribus. Serpentis tunc, diu fronde ni corpora alebat equidem oritur digna.","title":"About"},{"location":"about/#sit-super-quondam-una-boreas-opemque-intrare","text":"","title":"Sit super quondam una Boreas opemque intrare"},{"location":"about/#nebulas-laedat-retro-invaserat-attollo-nova","text":"Lorem markdownum non tantum excedere letifer et inque levis, illo ait : quis. Nantemque focus, ipsa vertitur foedoque nutrit quoniam mactandus modo semper rectum imagine: licet nitidaque diu inguine. Grates mea tardata pro potes ego, iter timidi rursusque futuri rettulit longis; nec frigus, molirique. coldWirelessFrame = e_rw_host(menu); baseband_access_icann.dualPrimaryUsername = processChipsetPci( keyIsp.bcc_metadata_bus(switchClient(gigaflopsCardModel))); if (plug_web) { byte_illegal(bezel, 4, smmKde); configurationKoffice += rich_kibibyte_clean; ntfs.docking_hertz -= mp; } else { kernelCell += vertical; } if (runtime <= mtu + 4 + udp_repository_mamp) { utf(4 + -2, printerServerScrolling, console_software_ole - 39); goodput_ppp_telnet.word.rpc(powerpoint_file_xp(4, surfaceCycleKbps, cps)); dithering_room_flops = 848275; } reciprocalOnly(51 / rwOn); Quod retentis iussum umquam operire glaebam postquam protinus ab fama. Ego gaudia virorum tyranni; hoc patuere medios, ergo Iove praebentem.","title":"Nebulas laedat retro invaserat attollo nova"},{"location":"about/#tamen-edentem-pudorem-mygdonidesque-aut-corpora-voti","text":"Ferox salibus fugatis semicaper tua praetemptatque tamen et altera equo possent hic ipse erigimur? Orbae meis ubi defecerat Cynthus ire haberet unda non non ripa sedula retinere certo illas arduus: tibi! Canit vultum vitae membra ille hic te gravatum pollice offensane aequor inde: aut tigres amore? Fuit velox eadem tollens, vocabere humus nescius adorat hinc penates gradumque saepe canes; culpa quoque illum, viribus. Nixique est mutua ipsa perdere elaborque priorum membra cum duplici; fluminis vulnere iaculatus quaerenti! Non et nubila silvis si possemque precari Oriens. Nam ante hic, vero animal inque labi ultima constiterant umbras scelus quandoquidem fortuna montes amantem dumque alii contenta. Dixit utque addita, belli animos Mensis linguae cum videre haec. Pulsus intenta deque admonuisse erat Acrisioniades abiit nescio. Munera vos dextra consequar ultro lacertos adstitit exul; ponere ruat undas. Colentes medeatur nunc tot sanguis vix certe iam taedae adludentibus quamvis regnaque portitor recepto in duxisses lacuque et ad non. Enim validi tactusque fuerit ultima te ubi et in increvisse in. Quod amatam exspectatus foret siccoque, solos mortale sequuntur refugam et armis mihi carmine? Omnes Cernis Latinum da Iuno forma veteremque sibilat vitamque nomine festa dies tum; merito sensit truncos eminet altaribus. Serpentis tunc, diu fronde ni corpora alebat equidem oritur digna.","title":"Tamen edentem pudorem Mygdonidesque aut corpora voti"},{"location":"LF/basics/","text":"Basics in Coq This document summarizes the key concepts from the Basics.v file in the Software Foundations series, which introduces fundamental Coq programming concepts. Introduction to Coq Coq is a proof assistant based on dependent type theory. It allows us to write functional programs, specify properties, and prove them formally. Key Concepts 1. Defining Functions and Values Functions are defined using the Definition keyword. Example: Definition plus_two (n : nat) : nat := n + 2. 2. Booleans Coq provides a bool type with two values: true and false . Boolean functions can be defined using pattern matching: Definition negb (b : bool) : bool := match b with | true => false | false => true end. Pattern matching can be defined in this case as : b either match true or false. 3. Numbers Coq includes a nat type for natural numbers. Constructors: O for zero. S for the successor function (e.g., S O is 1, S (S O) is 2). Example of addition: Fixpoint add (n m : nat) : nat := match n with | O => m | S n' => S (add n' m) end. 4. Proofs by Simplification Proofs can be done interactively using tactics like simpl and reflexivity . Example: Theorem plus_O_n : forall k : nat, 0 + k = k. Proof. simpl. reflexivity. Qed. In this case, simpl tactic will simplify 0 + k based on the construction of add. i.e add 0 k, n match O so the function returns k. simpl tactic can simplify this operation itself. Then when two operands are equal, it means we proved the theorem. Reflexivity tactic puts an end to the proof. 5. Inductive Types Custom types can be defined using Inductive . Example: Defining a day type: Inductive day : Type := | monday | tuesday | wednesday | thursday | friday | saturday | sunday. day is a new data type, and any variable of type day can have one of the values: monday, tuesday, wednesday, etc. 6. Pattern Matching Used to destructure data types. Example: Definition is_weekend (d : day) : bool := match d with | saturday | sunday => true | _ => false end. 7. Fixpoint Functions Recursive functions, needs to explicitly call back the function Example : Fixpoint plus (n : nat) (m : nat) : nat := match n with | O => m | S n' => S (plus n' m) end. Content List : Useful inductive Types Inductive bool : Type := | true | false. Inductive nat : Type := | O | S (n : nat). Inductive bin : Type := | Z | B0 (n : bin) | B1 (n : bin). Introduced Functions Introduced Notations Notation \"x + y\" := (plus x y) (at level 50, left associativity) : nat_scope. Notation \"x - y\" := (minus x y) (at level 50, left associativity) : nat_scope. Notation \"x * y\" := (mult x y) (at level 40, left associativity) : nat_scope. Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope. Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope. Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope. Notation \"x !& y\" := (nandb x y) (at level 40, left associativity). Notation \"x && y\" := (andb x y). Notation \"x || y\" := (orb x y). Proven Theorems zero_nbeq_plus_1 : forall n : nat, 0 =? (n + 1) = false. andb_commutative : forall b c, andb b c = andb c b. identity_fn_applied_twice : forall (f : bool -> bool), (forall (x : bool), f x = x) -> forall (b : bool), f (f b) = b. negation_fn_applied_twice : forall (f : bool -> bool), (forall (x : bool), f x = negb x) -> forall (b : bool), f (f b) = b. andb_eq_orb : forall (b c : bool), (andb b c = orb b c) -> b = c. plus_O_n : forall n : nat, 0 + n = n. plus_1_l : forall n:nat, 1 + n = S n. mult_0_l : forall n:nat, 0 * n = 0. plus_id_example : forall n m:nat, n = m -> n + n = m + m. mult_n_0_m_0 : forall p q : nat, (p * 0) + (q * 0) = 0. mult_n_1 : forall p : nat, p * 1 = p. plus_1_neq_0 : forall n : nat, (n + 1) =? 0 = false. Summary The Basics.v file introduces: - Core data types ( bool , nat , custom types). - Function definitions, recursive functions and pattern matching. - Proof techniques like simplification and induction. These concepts form the foundation for programming and proving in Coq. For more details, refer to the Software Foundations series.","title":"Basics"},{"location":"LF/basics/#basics-in-coq","text":"This document summarizes the key concepts from the Basics.v file in the Software Foundations series, which introduces fundamental Coq programming concepts.","title":"Basics in Coq"},{"location":"LF/basics/#introduction-to-coq","text":"Coq is a proof assistant based on dependent type theory. It allows us to write functional programs, specify properties, and prove them formally.","title":"Introduction to Coq"},{"location":"LF/basics/#key-concepts","text":"","title":"Key Concepts"},{"location":"LF/basics/#1-defining-functions-and-values","text":"Functions are defined using the Definition keyword. Example: Definition plus_two (n : nat) : nat := n + 2.","title":"1. Defining Functions and Values"},{"location":"LF/basics/#2-booleans","text":"Coq provides a bool type with two values: true and false . Boolean functions can be defined using pattern matching: Definition negb (b : bool) : bool := match b with | true => false | false => true end. Pattern matching can be defined in this case as : b either match true or false.","title":"2. Booleans"},{"location":"LF/basics/#3-numbers","text":"Coq includes a nat type for natural numbers. Constructors: O for zero. S for the successor function (e.g., S O is 1, S (S O) is 2). Example of addition: Fixpoint add (n m : nat) : nat := match n with | O => m | S n' => S (add n' m) end.","title":"3. Numbers"},{"location":"LF/basics/#4-proofs-by-simplification","text":"Proofs can be done interactively using tactics like simpl and reflexivity . Example: Theorem plus_O_n : forall k : nat, 0 + k = k. Proof. simpl. reflexivity. Qed. In this case, simpl tactic will simplify 0 + k based on the construction of add. i.e add 0 k, n match O so the function returns k. simpl tactic can simplify this operation itself. Then when two operands are equal, it means we proved the theorem. Reflexivity tactic puts an end to the proof.","title":"4. Proofs by Simplification"},{"location":"LF/basics/#5-inductive-types","text":"Custom types can be defined using Inductive . Example: Defining a day type: Inductive day : Type := | monday | tuesday | wednesday | thursday | friday | saturday | sunday. day is a new data type, and any variable of type day can have one of the values: monday, tuesday, wednesday, etc.","title":"5. Inductive Types"},{"location":"LF/basics/#6-pattern-matching","text":"Used to destructure data types. Example: Definition is_weekend (d : day) : bool := match d with | saturday | sunday => true | _ => false end.","title":"6. Pattern Matching"},{"location":"LF/basics/#7-fixpoint-functions","text":"Recursive functions, needs to explicitly call back the function Example : Fixpoint plus (n : nat) (m : nat) : nat := match n with | O => m | S n' => S (plus n' m) end.","title":"7. Fixpoint Functions"},{"location":"LF/basics/#content-list","text":"","title":"Content List :"},{"location":"LF/basics/#useful-inductive-types","text":"Inductive bool : Type := | true | false. Inductive nat : Type := | O | S (n : nat). Inductive bin : Type := | Z | B0 (n : bin) | B1 (n : bin).","title":"Useful inductive Types"},{"location":"LF/basics/#introduced-functions","text":"","title":"Introduced Functions"},{"location":"LF/basics/#introduced-notations","text":"Notation \"x + y\" := (plus x y) (at level 50, left associativity) : nat_scope. Notation \"x - y\" := (minus x y) (at level 50, left associativity) : nat_scope. Notation \"x * y\" := (mult x y) (at level 40, left associativity) : nat_scope. Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope. Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope. Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope. Notation \"x !& y\" := (nandb x y) (at level 40, left associativity). Notation \"x && y\" := (andb x y). Notation \"x || y\" := (orb x y).","title":"Introduced Notations"},{"location":"LF/basics/#proven-theorems","text":"zero_nbeq_plus_1 : forall n : nat, 0 =? (n + 1) = false. andb_commutative : forall b c, andb b c = andb c b. identity_fn_applied_twice : forall (f : bool -> bool), (forall (x : bool), f x = x) -> forall (b : bool), f (f b) = b. negation_fn_applied_twice : forall (f : bool -> bool), (forall (x : bool), f x = negb x) -> forall (b : bool), f (f b) = b. andb_eq_orb : forall (b c : bool), (andb b c = orb b c) -> b = c. plus_O_n : forall n : nat, 0 + n = n. plus_1_l : forall n:nat, 1 + n = S n. mult_0_l : forall n:nat, 0 * n = 0. plus_id_example : forall n m:nat, n = m -> n + n = m + m. mult_n_0_m_0 : forall p q : nat, (p * 0) + (q * 0) = 0. mult_n_1 : forall p : nat, p * 1 = p. plus_1_neq_0 : forall n : nat, (n + 1) =? 0 = false.","title":"Proven Theorems"},{"location":"LF/basics/#summary","text":"The Basics.v file introduces: - Core data types ( bool , nat , custom types). - Function definitions, recursive functions and pattern matching. - Proof techniques like simplification and induction. These concepts form the foundation for programming and proving in Coq. For more details, refer to the Software Foundations series.","title":"Summary"},{"location":"LF/imp/","text":"","title":"Imp"},{"location":"LF/indprop/","text":"Summary of Concepts from IndProp.v This document summarizes key concepts from the IndProp.v chapter of the Software Foundations Coq course. Inductive Propositions Inductive propositions are used to define logical properties and relations in Coq. They are similar to inductive types but represent logical statements. Example: Even Numbers Inductive ev : nat -> Prop := | ev_0 : ev 0 | ev_SS : forall n, ev n -> ev (S (S n)). ev_0 : Base case, stating that 0 is even. ev_SS : Inductive step, stating that if n is even, then S (S n) is also even. Proofs with Inductive Propositions Proofs involving inductive propositions often use: - Induction : To handle recursive structures. - Inversion : To analyze cases based on constructors. Example Proof Theorem ev_double : forall n, ev (double n). Proof. induction n. - apply ev_0. - simpl. apply ev_SS. apply IHn. Qed. Logical Connectives and Quantifiers Inductive definitions can encode logical connectives: - Conjunction ( /\\ ) : Defined using a constructor with two arguments. - Disjunction ( \\/ ) : Defined using multiple constructors. - Existential Quantification ( exists ) : Defined using a constructor with a dependent type. Example: Conjunction Inductive and (P Q : Prop) : Prop := | conj : P -> Q -> and P Q. Example: Disjunction Inductive or (P Q : Prop) : Prop := | or_introl : P -> or P Q | or_intror : Q -> or P Q. Relations Inductive propositions are often used to define relations between elements. Example: Less Than or Equal Inductive le : nat -> nat -> Prop := | le_n : forall n, le n n | le_S : forall n m, le n m -> le n (S m). le_n : Base case, n <= n . le_S : Inductive step, if n <= m , then n <= S m . Case Analysis and Inversion Case Analysis : Used to reason about all possible forms of a proposition. Inversion : Extracts information from hypotheses involving inductive propositions. Example: Inversion Theorem ev_inversion : forall n, ev n -> n = 0 \\/ exists n', n = S (S n') /\\ ev n'. Proof. intros n H. inversion H. - left. reflexivity. - right. exists n0. split; assumption. Qed. Conclusion The IndProp.v chapter introduces powerful tools for reasoning about logical properties and relations in Coq. By defining propositions inductively, we can construct proofs that are both rigorous and expressive.","title":"IndProp"},{"location":"LF/indprop/#summary-of-concepts-from-indpropv","text":"This document summarizes key concepts from the IndProp.v chapter of the Software Foundations Coq course.","title":"Summary of Concepts from IndProp.v"},{"location":"LF/indprop/#inductive-propositions","text":"Inductive propositions are used to define logical properties and relations in Coq. They are similar to inductive types but represent logical statements.","title":"Inductive Propositions"},{"location":"LF/indprop/#example-even-numbers","text":"Inductive ev : nat -> Prop := | ev_0 : ev 0 | ev_SS : forall n, ev n -> ev (S (S n)). ev_0 : Base case, stating that 0 is even. ev_SS : Inductive step, stating that if n is even, then S (S n) is also even.","title":"Example: Even Numbers"},{"location":"LF/indprop/#proofs-with-inductive-propositions","text":"Proofs involving inductive propositions often use: - Induction : To handle recursive structures. - Inversion : To analyze cases based on constructors.","title":"Proofs with Inductive Propositions"},{"location":"LF/indprop/#example-proof","text":"Theorem ev_double : forall n, ev (double n). Proof. induction n. - apply ev_0. - simpl. apply ev_SS. apply IHn. Qed.","title":"Example Proof"},{"location":"LF/indprop/#logical-connectives-and-quantifiers","text":"Inductive definitions can encode logical connectives: - Conjunction ( /\\ ) : Defined using a constructor with two arguments. - Disjunction ( \\/ ) : Defined using multiple constructors. - Existential Quantification ( exists ) : Defined using a constructor with a dependent type.","title":"Logical Connectives and Quantifiers"},{"location":"LF/indprop/#example-conjunction","text":"Inductive and (P Q : Prop) : Prop := | conj : P -> Q -> and P Q.","title":"Example: Conjunction"},{"location":"LF/indprop/#example-disjunction","text":"Inductive or (P Q : Prop) : Prop := | or_introl : P -> or P Q | or_intror : Q -> or P Q.","title":"Example: Disjunction"},{"location":"LF/indprop/#relations","text":"Inductive propositions are often used to define relations between elements.","title":"Relations"},{"location":"LF/indprop/#example-less-than-or-equal","text":"Inductive le : nat -> nat -> Prop := | le_n : forall n, le n n | le_S : forall n m, le n m -> le n (S m). le_n : Base case, n <= n . le_S : Inductive step, if n <= m , then n <= S m .","title":"Example: Less Than or Equal"},{"location":"LF/indprop/#case-analysis-and-inversion","text":"Case Analysis : Used to reason about all possible forms of a proposition. Inversion : Extracts information from hypotheses involving inductive propositions.","title":"Case Analysis and Inversion"},{"location":"LF/indprop/#example-inversion","text":"Theorem ev_inversion : forall n, ev n -> n = 0 \\/ exists n', n = S (S n') /\\ ev n'. Proof. intros n H. inversion H. - left. reflexivity. - right. exists n0. split; assumption. Qed.","title":"Example: Inversion"},{"location":"LF/indprop/#conclusion","text":"The IndProp.v chapter introduces powerful tools for reasoning about logical properties and relations in Coq. By defining propositions inductively, we can construct proofs that are both rigorous and expressive.","title":"Conclusion"},{"location":"LF/induction/","text":"Induction in Coq This document summarizes the key concepts of induction as introduced in the induction.v file from the Software Foundations (SF) Coq course. What is Induction? Induction is a fundamental proof technique used to reason about recursively defined structures or processes. In Coq, it is commonly applied to natural numbers, lists, and other inductive types. Inductive Definitions Natural Numbers The natural numbers ( nat ) are defined inductively in induction.v : Inductive nat : Type := | O : nat | S : nat -> nat. O represents zero. S is the successor function, representing the next natural number. Lists Lists are another example of an inductive type: Inductive list (X : Type) : Type := | nil : list X | cons : X -> list X -> list X. nil represents an empty list. cons constructs a list by adding an element to the front. Proof by Induction Structure of Inductive Proofs To prove a property P for an inductive type: 1. Base Case : Prove P for the simplest constructor (e.g., O for nat or nil for list ). 2. Inductive Step : Assume P holds for a smaller instance and prove it for the next constructor. Example: Addition is Associative The induction.v file demonstrates proofs like the associativity of addition: Theorem add_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Proof. intros n m p. induction n as [| n' IHn']. - (* Base case *) reflexivity. - (* Inductive step *) simpl. rewrite IHn'. reflexivity. Qed. Tactics for Induction induction : Automatically generates base and inductive cases. simpl : Simplifies expressions. rewrite : Substitutes equal terms. reflexivity : Proves equality. Common Pitfalls Forgetting Base Cases : Ensure all constructors are covered. Incorrect Inductive Hypothesis : Carefully state the property being proved. Overlooking Recursive Definitions : Use simpl to handle recursive functions. Exercises The induction.v file includes exercises to practice induction: 1. Prove that n + 0 = n for all natural numbers n . 2. Show that reversing a list twice yields the original list. Conclusion Induction is a powerful tool for reasoning about recursive structures. The induction.v file provides a solid foundation for mastering formal proofs in Coq.","title":"Induction"},{"location":"LF/induction/#induction-in-coq","text":"This document summarizes the key concepts of induction as introduced in the induction.v file from the Software Foundations (SF) Coq course.","title":"Induction in Coq"},{"location":"LF/induction/#what-is-induction","text":"Induction is a fundamental proof technique used to reason about recursively defined structures or processes. In Coq, it is commonly applied to natural numbers, lists, and other inductive types.","title":"What is Induction?"},{"location":"LF/induction/#inductive-definitions","text":"","title":"Inductive Definitions"},{"location":"LF/induction/#natural-numbers","text":"The natural numbers ( nat ) are defined inductively in induction.v : Inductive nat : Type := | O : nat | S : nat -> nat. O represents zero. S is the successor function, representing the next natural number.","title":"Natural Numbers"},{"location":"LF/induction/#lists","text":"Lists are another example of an inductive type: Inductive list (X : Type) : Type := | nil : list X | cons : X -> list X -> list X. nil represents an empty list. cons constructs a list by adding an element to the front.","title":"Lists"},{"location":"LF/induction/#proof-by-induction","text":"","title":"Proof by Induction"},{"location":"LF/induction/#structure-of-inductive-proofs","text":"To prove a property P for an inductive type: 1. Base Case : Prove P for the simplest constructor (e.g., O for nat or nil for list ). 2. Inductive Step : Assume P holds for a smaller instance and prove it for the next constructor.","title":"Structure of Inductive Proofs"},{"location":"LF/induction/#example-addition-is-associative","text":"The induction.v file demonstrates proofs like the associativity of addition: Theorem add_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Proof. intros n m p. induction n as [| n' IHn']. - (* Base case *) reflexivity. - (* Inductive step *) simpl. rewrite IHn'. reflexivity. Qed.","title":"Example: Addition is Associative"},{"location":"LF/induction/#tactics-for-induction","text":"induction : Automatically generates base and inductive cases. simpl : Simplifies expressions. rewrite : Substitutes equal terms. reflexivity : Proves equality.","title":"Tactics for Induction"},{"location":"LF/induction/#common-pitfalls","text":"Forgetting Base Cases : Ensure all constructors are covered. Incorrect Inductive Hypothesis : Carefully state the property being proved. Overlooking Recursive Definitions : Use simpl to handle recursive functions.","title":"Common Pitfalls"},{"location":"LF/induction/#exercises","text":"The induction.v file includes exercises to practice induction: 1. Prove that n + 0 = n for all natural numbers n . 2. Show that reversing a list twice yields the original list.","title":"Exercises"},{"location":"LF/induction/#conclusion","text":"Induction is a powerful tool for reasoning about recursive structures. The induction.v file provides a solid foundation for mastering formal proofs in Coq.","title":"Conclusion"},{"location":"LF/lists/","text":"Summary of Concepts from lists.v This document summarizes key concepts from the lists.v file in the Software Foundations Coq course. 1. Introduction to Lists Definition : A list is a sequence of elements of the same type. Syntax : Inductive list (X : Type) : Type := | nil : list X | cons : X -> list X -> list X. - `nil`: Represents an empty list. - `cons`: Constructs a list by adding an element to the front. 2. Basic List Operations length : Computes the number of elements in a list. Fixpoint length {X : Type} (l : list X) : nat := match l with | nil => 0 | cons _ t => 1 + length t end. app (append) : Concatenates two lists. Fixpoint app {X : Type} (l1 l2 : list X) : list X := match l1 with | nil => l2 | cons h t => cons h (app t l2) end. 3. List Notation Standard Notation : [] : Empty list. x :: xs : Cons operator. [x; y; z] : Shorthand for x :: y :: z :: [] . 4. Theorems and Proofs Associativity of app : Theorem app_assoc : forall X (l1 l2 l3 : list X), app l1 (app l2 l3) = app (app l1 l2) l3. - Proof involves induction on `l1`. Length of app : Theorem app_length : forall X (l1 l2 : list X), length (app l1 l2) = length l1 + length l2. 5. Polymorphism Lists in Coq are polymorphic, allowing elements of any type: Example: list nat , list bool , etc. 6. Higher-Order Functions map : Applies a function to each element of a list. Fixpoint map {X Y : Type} (f : X -> Y) (l : list X) : list Y := match l with | nil => nil | cons h t => cons (f h) (map f t) end. filter : Filters elements of a list based on a predicate. Fixpoint filter {X : Type} (test : X -> bool) (l : list X) : list X := match l with | nil => nil | cons h t => if test h then cons h (filter test t) else filter test t end. 7. List Membership In : Checks if an element exists in a list. Fixpoint In {X : Type} (x : X) (l : list X) : Prop := match l with | nil => False | cons h t => h = x \\/ In x t end. 8. Exercises Practice exercises in lists.v include: Proving properties of length , app , and map . Working with filter and In . Conclusion The lists.v file introduces fundamental concepts of lists in Coq, including their definition, operations, and associated theorems. Mastery of these concepts is essential for reasoning about data structures in Coq.","title":"Lists"},{"location":"LF/lists/#summary-of-concepts-from-listsv","text":"This document summarizes key concepts from the lists.v file in the Software Foundations Coq course.","title":"Summary of Concepts from lists.v"},{"location":"LF/lists/#1-introduction-to-lists","text":"Definition : A list is a sequence of elements of the same type. Syntax : Inductive list (X : Type) : Type := | nil : list X | cons : X -> list X -> list X. - `nil`: Represents an empty list. - `cons`: Constructs a list by adding an element to the front.","title":"1. Introduction to Lists"},{"location":"LF/lists/#2-basic-list-operations","text":"length : Computes the number of elements in a list. Fixpoint length {X : Type} (l : list X) : nat := match l with | nil => 0 | cons _ t => 1 + length t end. app (append) : Concatenates two lists. Fixpoint app {X : Type} (l1 l2 : list X) : list X := match l1 with | nil => l2 | cons h t => cons h (app t l2) end.","title":"2. Basic List Operations"},{"location":"LF/lists/#3-list-notation","text":"Standard Notation : [] : Empty list. x :: xs : Cons operator. [x; y; z] : Shorthand for x :: y :: z :: [] .","title":"3. List Notation"},{"location":"LF/lists/#4-theorems-and-proofs","text":"Associativity of app : Theorem app_assoc : forall X (l1 l2 l3 : list X), app l1 (app l2 l3) = app (app l1 l2) l3. - Proof involves induction on `l1`. Length of app : Theorem app_length : forall X (l1 l2 : list X), length (app l1 l2) = length l1 + length l2.","title":"4. Theorems and Proofs"},{"location":"LF/lists/#5-polymorphism","text":"Lists in Coq are polymorphic, allowing elements of any type: Example: list nat , list bool , etc.","title":"5. Polymorphism"},{"location":"LF/lists/#6-higher-order-functions","text":"map : Applies a function to each element of a list. Fixpoint map {X Y : Type} (f : X -> Y) (l : list X) : list Y := match l with | nil => nil | cons h t => cons (f h) (map f t) end. filter : Filters elements of a list based on a predicate. Fixpoint filter {X : Type} (test : X -> bool) (l : list X) : list X := match l with | nil => nil | cons h t => if test h then cons h (filter test t) else filter test t end.","title":"6. Higher-Order Functions"},{"location":"LF/lists/#7-list-membership","text":"In : Checks if an element exists in a list. Fixpoint In {X : Type} (x : X) (l : list X) : Prop := match l with | nil => False | cons h t => h = x \\/ In x t end.","title":"7. List Membership"},{"location":"LF/lists/#8-exercises","text":"Practice exercises in lists.v include: Proving properties of length , app , and map . Working with filter and In .","title":"8. Exercises"},{"location":"LF/lists/#conclusion","text":"The lists.v file introduces fundamental concepts of lists in Coq, including their definition, operations, and associated theorems. Mastery of these concepts is essential for reasoning about data structures in Coq.","title":"Conclusion"},{"location":"LF/logic/","text":"Logic in Coq This document summarizes key concepts from the logic.v file in the Software Foundations (SF) Coq course. Propositions and Proofs Propositions : Logical statements that can be true or false. Proofs : Evidence that a proposition is true, constructed in Coq using tactics. Logical Connectives Conjunction ( /\\ ) Represents \"and\". Example: P /\\ Q means both P and Q are true. Proof involves proving both P and Q . Disjunction ( \\/ ) Represents \"or\". Example: P \\/ Q means either P or Q (or both) are true. Proof involves proving at least one of P or Q . Implication ( -> ) Represents \"if-then\". Example: P -> Q means if P is true, then Q must also be true. Proof involves assuming P and deriving Q . Negation ( ~ ) Represents \"not\". Example: ~P means P is not true. Defined as P -> False . Falsehood ( False ) Represents a contradiction. Cannot be proven. Truth ( True ) Always true. Requires no proof. Quantifiers Universal Quantification ( forall ) Example: forall x, P(x) means P(x) is true for all x . Proof involves showing P(x) holds for an arbitrary x . Existential Quantification ( exists ) Example: exists x, P(x) means there exists an x such that P(x) is true. Proof involves providing a specific x and showing P(x) holds. Proof Techniques Introduction : Used to introduce assumptions or break down logical connectives. Elimination : Used to extract information from assumptions. Case Analysis : Used for disjunctions or inductive types. Contradiction : Used to prove False and derive negations. Classical vs Constructive Logic Constructive Logic : Proofs must constructively demonstrate truth. Classical Logic : Allows reasoning with the law of excluded middle ( P \\/ ~P ). Examples Conjunction Example Theorem and_example : forall P Q : Prop, P /\\ Q -> Q /\\ P. Proof. intros P Q [HP HQ]. split; assumption. Qed. Disjunction Example Theorem or_example : forall P Q : Prop, P -> P \\/ Q. Proof. intros P Q HP. left. assumption. Qed. Negation Example Theorem not_example : forall P : Prop, ~P -> (P -> False). Proof. intros P HNP HP. apply HNP. assumption. Qed. This document provides a concise overview of logical reasoning in Coq. For more details, refer to the logic.v file in the Software Foundations course.","title":"Logic"},{"location":"LF/logic/#logic-in-coq","text":"This document summarizes key concepts from the logic.v file in the Software Foundations (SF) Coq course.","title":"Logic in Coq"},{"location":"LF/logic/#propositions-and-proofs","text":"Propositions : Logical statements that can be true or false. Proofs : Evidence that a proposition is true, constructed in Coq using tactics.","title":"Propositions and Proofs"},{"location":"LF/logic/#logical-connectives","text":"","title":"Logical Connectives"},{"location":"LF/logic/#conjunction","text":"Represents \"and\". Example: P /\\ Q means both P and Q are true. Proof involves proving both P and Q .","title":"Conjunction (/\\)"},{"location":"LF/logic/#disjunction","text":"Represents \"or\". Example: P \\/ Q means either P or Q (or both) are true. Proof involves proving at least one of P or Q .","title":"Disjunction (\\/)"},{"location":"LF/logic/#implication-","text":"Represents \"if-then\". Example: P -> Q means if P is true, then Q must also be true. Proof involves assuming P and deriving Q .","title":"Implication (-&gt;)"},{"location":"LF/logic/#negation","text":"Represents \"not\". Example: ~P means P is not true. Defined as P -> False .","title":"Negation (~)"},{"location":"LF/logic/#falsehood-false","text":"Represents a contradiction. Cannot be proven.","title":"Falsehood (False)"},{"location":"LF/logic/#truth-true","text":"Always true. Requires no proof.","title":"Truth (True)"},{"location":"LF/logic/#quantifiers","text":"","title":"Quantifiers"},{"location":"LF/logic/#universal-quantification-forall","text":"Example: forall x, P(x) means P(x) is true for all x . Proof involves showing P(x) holds for an arbitrary x .","title":"Universal Quantification (forall)"},{"location":"LF/logic/#existential-quantification-exists","text":"Example: exists x, P(x) means there exists an x such that P(x) is true. Proof involves providing a specific x and showing P(x) holds.","title":"Existential Quantification (exists)"},{"location":"LF/logic/#proof-techniques","text":"Introduction : Used to introduce assumptions or break down logical connectives. Elimination : Used to extract information from assumptions. Case Analysis : Used for disjunctions or inductive types. Contradiction : Used to prove False and derive negations.","title":"Proof Techniques"},{"location":"LF/logic/#classical-vs-constructive-logic","text":"Constructive Logic : Proofs must constructively demonstrate truth. Classical Logic : Allows reasoning with the law of excluded middle ( P \\/ ~P ).","title":"Classical vs Constructive Logic"},{"location":"LF/logic/#examples","text":"","title":"Examples"},{"location":"LF/logic/#conjunction-example","text":"Theorem and_example : forall P Q : Prop, P /\\ Q -> Q /\\ P. Proof. intros P Q [HP HQ]. split; assumption. Qed.","title":"Conjunction Example"},{"location":"LF/logic/#disjunction-example","text":"Theorem or_example : forall P Q : Prop, P -> P \\/ Q. Proof. intros P Q HP. left. assumption. Qed.","title":"Disjunction Example"},{"location":"LF/logic/#negation-example","text":"Theorem not_example : forall P : Prop, ~P -> (P -> False). Proof. intros P HNP HP. apply HNP. assumption. Qed. This document provides a concise overview of logical reasoning in Coq. For more details, refer to the logic.v file in the Software Foundations course.","title":"Negation Example"},{"location":"LF/maps/","text":"","title":"Maps"},{"location":"LF/poly/","text":"Polymorphism in Coq This document summarizes key concepts from poly.v , part of the Software Foundations Coq course. Polymorphic Functions and Types Polymorphic Lists Coq supports polymorphic data types, such as list , which can hold elements of any type. Example definition: Inductive list (X : Type) : Type := | nil : list X | cons : X -> list X -> list X. X is a type parameter, making list polymorphic. Polymorphic Functions Functions can also be polymorphic, operating on any type. Example: length function for lists: Fixpoint length {X : Type} (l : list X) : nat := match l with | nil => 0 | cons _ t => 1 + length t end. Higher-Order Functions Functions that take other functions as arguments or return functions as results. Example: map function applies a function to each element of a list: Fixpoint map {X Y : Type} (f : X -> Y) (l : list X) : list Y := match l with | nil => nil | cons h t => cons (f h) (map f t) end. Type Inference and Annotations Coq can often infer types, but explicit annotations can improve readability and debugging. Example: Definition id {X : Type} (x : X) : X := x. Exercises and Proofs poly.v includes exercises to practice reasoning about polymorphic functions and proving properties about them. Example proof: map preserves list length: Theorem map_length : forall (X Y : Type) (f : X -> Y) (l : list X), length (map f l) = length l. Proof. intros X Y f l. induction l as [| h t IH]. - reflexivity. - simpl. rewrite IH. reflexivity. Qed. Key Takeaways Polymorphism allows for reusable and generic definitions. Higher-order functions enable powerful abstractions. Coq's type system ensures correctness through proofs. For more details, refer to the poly.v file in the Software Foundations course.","title":"Poly"},{"location":"LF/poly/#polymorphism-in-coq","text":"This document summarizes key concepts from poly.v , part of the Software Foundations Coq course.","title":"Polymorphism in Coq"},{"location":"LF/poly/#polymorphic-functions-and-types","text":"","title":"Polymorphic Functions and Types"},{"location":"LF/poly/#polymorphic-lists","text":"Coq supports polymorphic data types, such as list , which can hold elements of any type. Example definition: Inductive list (X : Type) : Type := | nil : list X | cons : X -> list X -> list X. X is a type parameter, making list polymorphic.","title":"Polymorphic Lists"},{"location":"LF/poly/#polymorphic-functions","text":"Functions can also be polymorphic, operating on any type. Example: length function for lists: Fixpoint length {X : Type} (l : list X) : nat := match l with | nil => 0 | cons _ t => 1 + length t end.","title":"Polymorphic Functions"},{"location":"LF/poly/#higher-order-functions","text":"Functions that take other functions as arguments or return functions as results. Example: map function applies a function to each element of a list: Fixpoint map {X Y : Type} (f : X -> Y) (l : list X) : list Y := match l with | nil => nil | cons h t => cons (f h) (map f t) end.","title":"Higher-Order Functions"},{"location":"LF/poly/#type-inference-and-annotations","text":"Coq can often infer types, but explicit annotations can improve readability and debugging. Example: Definition id {X : Type} (x : X) : X := x.","title":"Type Inference and Annotations"},{"location":"LF/poly/#exercises-and-proofs","text":"poly.v includes exercises to practice reasoning about polymorphic functions and proving properties about them. Example proof: map preserves list length: Theorem map_length : forall (X Y : Type) (f : X -> Y) (l : list X), length (map f l) = length l. Proof. intros X Y f l. induction l as [| h t IH]. - reflexivity. - simpl. rewrite IH. reflexivity. Qed.","title":"Exercises and Proofs"},{"location":"LF/poly/#key-takeaways","text":"Polymorphism allows for reusable and generic definitions. Higher-order functions enable powerful abstractions. Coq's type system ensures correctness through proofs. For more details, refer to the poly.v file in the Software Foundations course.","title":"Key Takeaways"},{"location":"LF/tactics/","text":"Tactics in Coq This document summarizes key concepts and tactics from the Software Foundations (SF) course, focusing on the tactics.v file. Basic Tactics intros Moves hypotheses or variables from the goal into the context. reflexivity Solves goals where both sides of the equation are identical. apply Uses a hypothesis, lemma, or theorem to prove the goal. exact Provides the exact term that matches the goal. assumption Solves the goal if it matches a hypothesis in the context. Structural Tactics split Breaks conjunctions ( A /\\ B ) into separate subgoals. left / right Chooses a branch in a disjunction ( A \\/ B ). destruct Performs case analysis on a term. induction Applies induction on a variable, generating base and inductive cases. Simplification Tactics simpl Simplifies computations in the goal. rewrite Replaces terms using equalities from hypotheses or lemmas. unfold Expands a defined term in the goal. fold Collapses a term back into its defined form. Logical Tactics assert Introduces an intermediate assertion to simplify proofs. exists Provides a witness to prove existential quantifiers ( exists x, P x ). inversion Analyzes equalities to extract information from constructors. Automation auto Attempts to solve goals using simple reasoning and existing hypotheses. eauto Extends auto with additional search capabilities. repeat Repeats a tactic until it fails. try Attempts a tactic but does not fail if the tactic does. Debugging info_auto Displays the steps taken by auto . idtac Prints custom messages for debugging. This summary provides a foundation for understanding Coq tactics. Refer to the tactics.v file for detailed examples and exercises.","title":"Tactics"},{"location":"LF/tactics/#tactics-in-coq","text":"This document summarizes key concepts and tactics from the Software Foundations (SF) course, focusing on the tactics.v file.","title":"Tactics in Coq"},{"location":"LF/tactics/#basic-tactics","text":"","title":"Basic Tactics"},{"location":"LF/tactics/#intros","text":"Moves hypotheses or variables from the goal into the context.","title":"intros"},{"location":"LF/tactics/#reflexivity","text":"Solves goals where both sides of the equation are identical.","title":"reflexivity"},{"location":"LF/tactics/#apply","text":"Uses a hypothesis, lemma, or theorem to prove the goal.","title":"apply"},{"location":"LF/tactics/#exact","text":"Provides the exact term that matches the goal.","title":"exact"},{"location":"LF/tactics/#assumption","text":"Solves the goal if it matches a hypothesis in the context.","title":"assumption"},{"location":"LF/tactics/#structural-tactics","text":"","title":"Structural Tactics"},{"location":"LF/tactics/#split","text":"Breaks conjunctions ( A /\\ B ) into separate subgoals.","title":"split"},{"location":"LF/tactics/#left-right","text":"Chooses a branch in a disjunction ( A \\/ B ).","title":"left / right"},{"location":"LF/tactics/#destruct","text":"Performs case analysis on a term.","title":"destruct"},{"location":"LF/tactics/#induction","text":"Applies induction on a variable, generating base and inductive cases.","title":"induction"},{"location":"LF/tactics/#simplification-tactics","text":"","title":"Simplification Tactics"},{"location":"LF/tactics/#simpl","text":"Simplifies computations in the goal.","title":"simpl"},{"location":"LF/tactics/#rewrite","text":"Replaces terms using equalities from hypotheses or lemmas.","title":"rewrite"},{"location":"LF/tactics/#unfold","text":"Expands a defined term in the goal.","title":"unfold"},{"location":"LF/tactics/#fold","text":"Collapses a term back into its defined form.","title":"fold"},{"location":"LF/tactics/#logical-tactics","text":"","title":"Logical Tactics"},{"location":"LF/tactics/#assert","text":"Introduces an intermediate assertion to simplify proofs.","title":"assert"},{"location":"LF/tactics/#exists","text":"Provides a witness to prove existential quantifiers ( exists x, P x ).","title":"exists"},{"location":"LF/tactics/#inversion","text":"Analyzes equalities to extract information from constructors.","title":"inversion"},{"location":"LF/tactics/#automation","text":"","title":"Automation"},{"location":"LF/tactics/#auto","text":"Attempts to solve goals using simple reasoning and existing hypotheses.","title":"auto"},{"location":"LF/tactics/#eauto","text":"Extends auto with additional search capabilities.","title":"eauto"},{"location":"LF/tactics/#repeat","text":"Repeats a tactic until it fails.","title":"repeat"},{"location":"LF/tactics/#try","text":"Attempts a tactic but does not fail if the tactic does.","title":"try"},{"location":"LF/tactics/#debugging","text":"","title":"Debugging"},{"location":"LF/tactics/#info_auto","text":"Displays the steps taken by auto .","title":"info_auto"},{"location":"LF/tactics/#idtac","text":"Prints custom messages for debugging. This summary provides a foundation for understanding Coq tactics. Refer to the tactics.v file for detailed examples and exercises.","title":"idtac"},{"location":"PLF/program_equivalence/","text":"TODO","title":"Program equivalence"},{"location":"PLF/program_equivalence/#todo","text":"","title":"TODO"},{"location":"PLF/small_step/","text":"TODO","title":"Small-step"},{"location":"PLF/small_step/#todo","text":"","title":"TODO"}]}